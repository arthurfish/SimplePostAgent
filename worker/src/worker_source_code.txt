import {Context, Effect} from "effect";

export class LLMService extends Context.Tag("LLMService")<
    LLMService,
    {
        plan: (input: string) => Effect.Effect<any[], Error>;
        execute: (prompt: string, updateFn: (state: string) => Effect.Effect<void, never>) => Effect.Effect<string, Error>;
        aggregate: (results: { task_title: string; result_content: string }[], updateFn: ((state: string) => Effect.Effect<void, never>)) => Effect.Effect<string, Error>;
    }
>() {}// src/db.ts
import postgres from "postgres";
import { Effect, Context, Layer, Config } from "effect";
import {Console} from "effect/Console";

// å®šä¹‰æœåŠ¡æ¥å£ (Tag)
export class Database extends Context.Tag("Database")<
  Database,
  ReturnType<typeof makeDbImpl>
>() {}

// å®ç°
const makeDbImpl = (sql: postgres.Sql) => ({
  // 1. è·å–å¾…æ‹†è§£çš„ä»»åŠ¡ (Planner Job)
  // SKIP LOCKED æ˜¯å…³é”®: å®ƒä¼šè·³è¿‡è¢«å…¶ä»–äº‹åŠ¡é”å®šçš„è¡Œ
  fetchPendingRequests: () =>
    Effect.tryPromise(() =>
      sql`
        SELECT id, user_input 
        FROM requests 
        WHERE status = 'pending' 
        FOR UPDATE SKIP LOCKED 
        LIMIT 5
      `
    ),

  // 2. è·å–å¾…æ‰§è¡Œçš„å­ä»»åŠ¡ (Executor Job)
  fetchPendingSubTasks: () =>
    Effect.tryPromise(() =>
      sql`
        SELECT id, prompt_content 
        FROM sub_tasks 
        WHERE status = 'pending' 
        FOR UPDATE SKIP LOCKED 
        LIMIT 10
      `
    ),

  // 3. è·å–å¾…æ±‡æ€»çš„ä»»åŠ¡ (Aggregator Job)
  fetchAggregatingRequests: () =>
    Effect.tryPromise(() =>
      sql`
        SELECT id 
        FROM requests 
        WHERE status = 'aggregating' 
        FOR UPDATE SKIP LOCKED 
        LIMIT 5
      `
    ),
    
  // 4. è·å–æŸä¸ª Request çš„æ‰€æœ‰å·²å®Œæˆå­ä»»åŠ¡ç»“æœ (ç”¨äºæ±‡æ€»)
  fetchCompletedSubTasks: (requestId: string) =>
    Effect.tryPromise(() =>
        sql`
            SELECT task_title, result_content 
            FROM sub_tasks 
            WHERE request_id = ${requestId} AND status = 'completed'
        `
    ),

  // --- RPC è°ƒç”¨å°è£… (ä¸ Phase 1 å®šä¹‰çš„å­˜å‚¨è¿‡ç¨‹ä¸€è‡´) ---

  submitPlan: (requestId: string, planJson: any) =>
    Effect.tryPromise(() =>
      sql`CALL submit_plan(${requestId}, ${sql.json(planJson)})`
    ),

  submitSubTaskResult: (taskId: string, result: string) =>
    Effect.tryPromise(() =>
      sql`CALL submit_subtask_result(${taskId}, ${result})`
    ),
    updateSubtaskTemporaryState: (taskId: string, result: string) =>
        Effect.tryPromise(() =>
            sql`CALL update_subtask_temporary_state(${taskId}, ${result})`
        ),
  submitFinalReport: (requestId: string, report: string) =>
    Effect.tryPromise(() =>
      sql`CALL submit_final_report(${requestId}, ${report})`
    ),

    updateTemporaryFinalReport: (requestId: string, report: string) =>
        Effect.tryPromise(() =>
            sql`CALL update_temporary_final_report(${requestId}, ${report})`
        ),
  markRequestFailed: (requestId: string, error: string) =>
    Effect.tryPromise(() =>
      sql`CALL submit_request_failure(${requestId}, ${error})`
    ),

  markSubTaskFailed: (taskId: string, error: string) =>
    Effect.tryPromise(() =>
      sql`CALL submit_subtask_failure(${taskId}, ${error})`
    ),
});

// Layer å®šä¹‰
export const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    const url = yield* Config.string("DATABASE_URL").pipe(
        Config.withDefault("postgres://postgres:password@localhost:5432/simple_agent")
    );
    const sql = postgres(url, { transform: { undefined: null } });
    return makeDbImpl(sql);
  })
);
// src/index.ts
import { Effect, Schedule, Layer } from "effect";
import { NodeRuntime } from "@effect/platform-node";
import { DatabaseLive } from "./db";
import { VolcanoLLM } from "./real_llm";
import {MockLLM} from "./llm"
import { runPlanner, runExecutor, runAggregator } from "./workflow";

// ä¸»å¾ªç¯ç­–ç•¥
const schedulePolicy = Schedule.spaced("1 seconds"); // æ¯ç§’è½®è¯¢ä¸€æ¬¡

const mainLoop = Effect.gen(function* () {
  yield* Effect.log("ğŸš€ SimplePostAgent Worker Started");

  // æˆ‘ä»¬å¯ä»¥è®©ä¸‰ä¸ª Loop å¹¶è¡Œè¿è¡Œï¼Œäº’ä¸é˜»å¡
  const plannerLoop = runPlanner.pipe(Effect.repeat(schedulePolicy));
  const executorLoop = runExecutor.pipe(Effect.repeat(schedulePolicy));
  const aggregatorLoop = runAggregator.pipe(Effect.repeat(schedulePolicy));

  // ç»„åˆå¹¶è¿è¡Œ (æ°¸è¿œä¸ä¼šç»“æŸï¼Œé™¤éè¢« Kill)
  yield* Effect.all([plannerLoop, executorLoop, aggregatorLoop], { concurrency: "unbounded" });
});

// ä¾èµ–æ³¨å…¥
const program = mainLoop.pipe(
  Effect.provide(DatabaseLive),
  Effect.provide(VolcanoLLM)
);

NodeRuntime.runMain(program);
// src/llm.ts
import { Effect, Context, Layer, Schedule, Random } from "effect";

export class LLMService extends Context.Tag("LLMService")<
  LLMService,
  {
    plan: (input: string) => Effect.Effect<any[], Error>;
    execute: (prompt: string) => Effect.Effect<string, Error>;
    aggregate: (results: { task_title: string; result_content: string }[]) => Effect.Effect<string, Error>;
  }
>() {}

export const MockLLM = Layer.succeed(LLMService, {
  // Planner: æ°¸è¿œæŠŠä»»åŠ¡æ‹†æˆ 3 ä¸ª
  plan: (input) =>
    Effect.gen(function* () {
      yield* Effect.log(`[MockLLM] Planning for: "${input}"`);
      yield* Effect.sleep("1 seconds"); // æ€è€ƒæ—¶é—´
      return [
        { title: "Step 1: Research", prompt: `Research: ${input}` },
        { title: "Step 2: Analysis", prompt: `Analyze: ${input}` },
        { title: "Step 3: Conclusion", prompt: `Conclude: ${input}` },
      ];
    }),

  // Executor: æ¨¡æ‹Ÿæ‰§è¡Œï¼Œå¸¦æœ‰éšæœºå¤±è´¥
  execute: (prompt) =>
    Effect.gen(function* () {
      yield* Effect.log(`[MockLLM] Executing: "${prompt}"`);
      
      // æ¨¡æ‹Ÿ 20% çš„æ¦‚ç‡å¤±è´¥ (æµ‹è¯•é‡è¯•æœºåˆ¶)
      if (Math.random() < 0.2) {
          yield* Effect.fail(new Error("Random API Failure (Simulated)"));
      }
      if (prompt.includes("poison")) {
          // æ¨¡æ‹Ÿä¸€ä¸ªéé¢„æœŸé”™è¯¯ï¼ˆDefectï¼‰
          yield* Effect.die(new Error("FATAL POISON PILL ERROR"));
      }
      yield* Effect.sleep("2 seconds"); // æ¨¡æ‹Ÿè€—æ—¶
      return `Result for [${prompt}]: Lorem ipsum data...`;
    }),

  // Aggregator: ç®€å•çš„æ–‡æœ¬æ‹¼æ¥
  aggregate: (results) =>
    Effect.gen(function* () {
      yield* Effect.log(`[MockLLM] Aggregating ${results.length} results`);
      yield* Effect.sleep("1 seconds");
      const summary = results
        .map((r) => `## ${r.task_title}\n${r.result_content}`)
        .join("\n\n");
      return `# Final Report\n\n${summary}`;
    }),
});



// src/llm.ts
import { Effect, Context, Layer } from "effect";

// ä¿æŒè¿™ä¸ª Service Tag æ¥å£ä¸å˜ï¼Œè¿™æ˜¯æˆ‘ä»¬å¯¹å¤–çš„å¥‘çº¦
export class LLMService extends Context.Tag("LLMService")<
    LLMService,
    {
        plan: (input: string) => Effect.Effect<any[], Error>;
        execute: (prompt: string) => Effect.Effect<string, Error>;
        aggregate: (results: { task_title: string; result_content: string }[]) => Effect.Effect<string, Error>;
    }
>() {}

/**
 * ä¸€ä¸ªé€šç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œç”¨äºè°ƒç”¨ç«å±±å¼•æ“å¤§æ¨¡å‹ API
 * @param messages - å‘é€ç»™æ¨¡å‹çš„å¯¹è¯æ¶ˆæ¯åˆ—è¡¨
 * @param response_format - å¯é€‰ï¼Œç”¨äºæŒ‡å®šæ¨¡å‹è¿”å›çš„æ ¼å¼ (ä¾‹å¦‚ JSON)
 * @returns Effect.Effect<string, Error> - è¿”å›æ¨¡å‹çš„æ–‡æœ¬å“åº”
 */
const callVolcanoAPI = (messages: object[], response_format?: object): Effect.Effect<string, Error> =>
    Effect.gen(function* () {
        const apiKey = process.env.ARK_API_KEY;
        if (!apiKey) {
            return yield* Effect.fail(new Error("ARK_API_KEY ç¯å¢ƒå˜é‡æœªè®¾ç½®ï¼Œè¯·æ£€æŸ¥ã€‚"));
        }

        const body = {
            model: "doubao-seed-1-6-flash-250828", // ä½¿ç”¨ä¸€ä¸ªæ¯”è¾ƒé€šç”¨çš„æ¨¡å‹
            messages,
            ...response_format,
        };

        const response = yield* Effect.tryPromise({
            try: () => fetch("https://ark.cn-beijing.volces.com/api/v3/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                },
                body: JSON.stringify(body),
            }),
            catch: (error) => new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`),
        });

        if (!response.ok) {
            const errorText = yield* Effect.promise(() => response.text());
            return yield* Effect.fail(new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`));
        }

        const json = (yield* Effect.promise(() => response.json())) as any;

        // æ£€æŸ¥è¿”å›çš„æ•°æ®ç»“æ„æ˜¯å¦ç¬¦åˆé¢„æœŸ
        if (!json.choices || json.choices.length === 0 || !json.choices[0].message) {
            return yield* Effect.fail(new Error("API è¿”å›äº†éé¢„æœŸçš„æ ¼å¼ã€‚"));
        }

        return json.choices[0].message.content;
    });

// è¿™æ˜¯ LLMService çš„çœŸå®ç«å±±å¼•æ“å®ç°
export const VolcanoLLM = Layer.succeed(LLMService, {
    // Planner: è°ƒç”¨æ¨¡å‹ï¼Œè®©å®ƒæŠŠä»»åŠ¡æ‹†è§£æˆ JSON æ ¼å¼çš„æ­¥éª¤
    plan: (input) => Effect.gen(function* () {
        yield* Effect.log(`[VolcanoLLM] Planning for: "${input}"`);

        const messages = [
            {
                role: "system",
                content: "æ ¹æ®ç”¨æˆ·çš„è¯·æ±‚ï¼Œå°†è¿™ä¸ªé—®é¢˜çš„å›ç­”åˆ’åˆ†ä¸ºç›¸å…³çš„å­é—®é¢˜ï¼Œåˆ†è€Œæ²»ä¹‹è¿›è¡Œè§£å†³ã€‚è¯·ä¸¥æ ¼æŒ‰ç…§æŒ‡å®šçš„ JSON æ ¼å¼è¿”å›è®¡åˆ’ã€‚",
            },
            {
                role: "user",
                content: input,
            },
        ];

        // å®šä¹‰æˆ‘ä»¬æœŸæœ›æ¨¡å‹è¿”å›çš„ JSON ç»“æ„
        const response_format = {
            response_format: {
                type: "json_schema",
                json_schema: {
                    name: "task_plan",
                    schema: {
                        type: "object",
                        properties: {
                            tasks: {
                                type: "array",
                                items: {
                                    type: "object",
                                    properties: {
                                        title: { type: "string", description: "ä»»åŠ¡çš„ç®€çŸ­æ ‡é¢˜" },
                                        prompt: { type: "string", description: "æ‰§è¡Œè¯¥ä»»åŠ¡æ‰€éœ€çš„è¯¦ç»†æŒ‡ä»¤æˆ–é—®é¢˜" },
                                    },
                                    required: ["title", "prompt"],
                                },
                            },
                        },
                        required: ["tasks"],
                    },
                    strict: true,
                },
            },
        };

        // è°ƒç”¨ API å¹¶æœŸæœ›è¿”å›ä¸€ä¸ª JSON å­—ç¬¦ä¸²
        const jsonString = yield* callVolcanoAPI(messages, response_format);


        // è§£æ JSON å­—ç¬¦ä¸²
        const result = yield* Effect.try({
            try: () => JSON.parse(jsonString),
            catch: (error) => new Error(`è§£æ Plan è¿”å›çš„ JSON å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
        }).pipe(
            //Effect.tap(x => console.log(x))
        );

        // ä»è§£æåçš„ç»“æœä¸­æå– tasks æ•°ç»„
        if (!result.tasks || !Array.isArray(result.tasks)) {
            return yield* Effect.fail(new Error("Plan è¿”å›çš„ JSON æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ 'tasks' æ•°ç»„ã€‚"));
        }

        return result.tasks;
    }),

    // Executor: ç›´æ¥æ‰§è¡Œä¸€ä¸ª promptï¼Œè¿”å›æ–‡æœ¬ç»“æœ
    execute: (prompt) => Effect.gen(function* () {
        yield* Effect.log(`[VolcanoLLM] Executing: "${prompt}"`);

        const messages = [
            {
                role: "system",
                content: "è¯·å°½å¯èƒ½è¯¦ç»†ï¼Œæ·±åº¦çš„å®Œæˆç”¨æˆ·æŒ‡å®šçš„ä»»åŠ¡ã€‚",
            },
            {
                role: "user",
                content: prompt,
            },
        ];

        return yield* callVolcanoAPI(messages);
    }),

    // Aggregator: å°†å¤šä¸ªä»»åŠ¡çš„ç»“æœæ±‡æ€»æˆä¸€ä»½æœ€ç»ˆæŠ¥å‘Š
    aggregate: (results) => Effect.gen(function* () {
        yield* Effect.log(`[VolcanoLLM] Aggregating ${results.length} results`);

        // å°†æ‰€æœ‰å­ä»»åŠ¡çš„ç»“æœæ ¼å¼åŒ–æˆä¸€ä¸ªå¤§çš„ prompt
        const combinedResults = results
            .map((r) => `## ä»»åŠ¡: ${r.task_title}\n\nç»“æœ:\n${r.result_content}`)
            .join("\n\n---\n\n");

        const messages = [
            {
                role: "system",
                content: "ä½ æ˜¯ä¸€ä¸ªæŠ¥å‘Šæ’°å†™ä¸“å®¶ã€‚è¯·æ ¹æ®ä»¥ä¸‹åˆ†æ­¥ä»»åŠ¡çš„ç»“æœï¼Œæ•´åˆå¹¶ç”Ÿæˆä¸€ä»½æ¸…æ™°ã€è¿è´¯çš„æœ€ç»ˆç»¼åˆæŠ¥å‘Šã€‚ä¸è¦åŒ…å«ä»»åŠ¡çš„åŸå§‹æ ‡é¢˜å’Œå†…å®¹ï¼Œè€Œæ˜¯å°†å®ƒä»¬è‡ªç„¶åœ°èåˆåˆ°æŠ¥å‘Šä¸­ã€‚",
            },
            {
                role: "user",
                content: `è¯·åŸºäºä»¥ä¸‹å†…å®¹ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Šï¼š\n\n${combinedResults}`,
            },
        ];

        return yield* callVolcanoAPI(messages);
    }),
});// worker/src/workflow.ts
import { Effect, Schedule, pipe, Cause } from "effect";
import { Database } from "./db";
import { LLMService } from "./real_llm";

// è¾…åŠ©å‡½æ•°ï¼šå¤„ç†å•ä¸ª Job çš„ç”Ÿå‘½å‘¨æœŸï¼Œç¡®ä¿å®ƒè¦ä¹ˆæˆåŠŸï¼Œè¦ä¹ˆè¢«æ ‡è®°ä¸º Failed
const handleJob = <E>(
  jobId: string,
  taskName: string,
  logic: Effect.Effect<void, E, Database | LLMService>,
  onFail: (db: any, errorMsg: string) => Effect.Effect<void>
) =>
  Effect.gen(function* () {
    const db = yield* Database;

    // è¿è¡Œä¸šåŠ¡é€»è¾‘ï¼Œæ•è·æ‰€æœ‰å¯èƒ½çš„é”™è¯¯ï¼ˆåŒ…æ‹¬ç¼ºé™· Defectï¼‰
    const exit = yield* logic.pipe(Effect.exit);

    if (exit._tag === "Failure") {
      // è§£æé”™è¯¯ä¿¡æ¯
      const errorMsg = Cause.pretty(exit.cause);
      yield* Effect.logError(`[${taskName}] Job ${jobId} CRASHED: ${errorMsg}`);
      
      // â˜…â˜…â˜… å…³é”®ç‚¹ï¼šå†™å…¥æ•°æ®åº“å¤±è´¥çŠ¶æ€ï¼Œæ‰“ç ´æ­»å¾ªç¯ â˜…â˜…â˜…
      // è¿™é‡Œå¦‚æœä¸æˆåŠŸï¼ˆæ¯”å¦‚æ•°æ®åº“æŒ‚äº†ï¼‰ï¼Œæˆ‘ä»¬ä¹Ÿæ— èƒ½ä¸ºåŠ›ï¼Œåªèƒ½è®©å®ƒ crash
      yield* onFail(db, errorMsg);
    }
  });

// ------------------------------------------------------------------
// 1. Planner Workflow (Robust)
// ------------------------------------------------------------------
export const runPlanner = Effect.gen(function* () {
  const db = yield* Database;
  const llm = yield* LLMService;

  const jobs = yield* db.fetchPendingRequests();
  if (jobs.length === 0) return;

  yield* Effect.forEach(
    jobs,
    (job) =>
      handleJob(
        job.id,
        "Planner",
        Effect.gen(function* () {
          const plan = yield* llm.plan(job.user_input);
          yield* db.submitPlan(job.id, plan);
          yield* Effect.log(`[Planner] Plan submitted for ${job.id}`);
        }),
        // å¤±è´¥å›è°ƒ
        (db, msg) => db.markRequestFailed(job.id, msg)
      ),
    { concurrency: 5 }
  );
});

// ------------------------------------------------------------------
// 2. Executor Workflow (Robust)
// ------------------------------------------------------------------
export const runExecutor = Effect.gen(function* () {
  const db = yield* Database;
  const llm = yield* LLMService;

  const tasks = yield* db.fetchPendingSubTasks();
  if (tasks.length === 0) return;

  yield* Effect.forEach(
    tasks,
    (task) =>
      handleJob(
        task.id,
        "Executor",
        Effect.gen(function* () {
          // è¿™é‡Œå¯ä»¥æ˜¯æ›´å¤æ‚çš„é‡è¯•é€»è¾‘
          const result = yield* llm.execute(task.prompt_content).pipe(
            Effect.retry({
              schedule: Schedule.exponential("500 millis").pipe(
                Schedule.intersect(Schedule.recurs(3)) // æœ€å¤šé‡è¯•3æ¬¡
              ),
            })
          );
          yield* db.submitSubTaskResult(task.id, result);
          yield* Effect.log(`[Executor] Task ${task.id} done`);
        }),
        // å¤±è´¥å›è°ƒï¼šè¿™ä¼šè§¦å‘æ•°æ®åº“ Triggerï¼Œå¯¼è‡´æ•´ä¸ª Request å¤±è´¥
        (db, msg) => db.markSubTaskFailed(task.id, msg)
      ),
    { concurrency: 20 }
  );
});

// ------------------------------------------------------------------
// 3. Aggregator Workflow (Robust)
// ------------------------------------------------------------------
export const runAggregator = Effect.gen(function* () {
  const db = yield* Database;
  const llm = yield* LLMService;

  const jobs = yield* db.fetchAggregatingRequests();
  if (jobs.length === 0) return;

  yield* Effect.forEach(
    jobs,
    (job) =>
      handleJob(
        job.id,
        "Aggregator",
        Effect.gen(function* () {
          const subTasks = yield* db.fetchCompletedSubTasks(job.id);
          const report = yield* llm.aggregate(subTasks as any);
          yield* db.submitFinalReport(job.id, report);
          yield* Effect.log(`[Aggregator] Report generated for ${job.id}`);
        }),
        (db, msg) => db.markRequestFailed(job.id, msg)
      ),
    { concurrency: 2 }
  );
});
